local runService = game:GetService('RunService')
local coregui = game:GetService('CoreGui')
local players = game:GetService('Players')
local localPlayer = players.LocalPlayer
local camera = workspace.CurrentCamera

local esp = {
    -- settings
    enabled = false,
    teamcheck = true,
    visiblecheck = false,
    outlines = true,
    limitdistance = false,
    shortnames = false,

    maxchar = 4,
    maxdistance = 1200,
    fadefactor = 20,
    arrowradius = 500,
    arrowsize = 20,
    arrowinfo = false,

    -- instances
    -- teammates
    team_chams = { false, Color3.new(1, 1, 1), Color3.new(1, 1, 1), .25, .75, true },
    team_boxes = { false, Color3.new(), Color3.new(), 0.95 },
    team_healthbar = { false, Color3.new(), Color3.new() },
    team_kevlarbar = { false, Color3.new(), Color3.new() },
    team_arrow = { false, Color3.new(), 0.5 },
    team_names = { false, Color3.new()},
    team_weapon = { false, Color3.new()},
    team_distance = false,
    team_health = false,

    -- enemies
    enemy_chams = { false, Color3.new(1, 1, 1), Color3.new(1, 1, 1), .25, .75, true },
    enemy_boxes = { false, Color3.new(), Color3.new(), 0.95 },
    enemy_healthbar = { false, Color3.new(), Color3.new() },
    enemy_kevlarbar = { false, Color3.new(), Color3.new() },
    enemy_arrow = { false, Color3.new(), 0.5 },
    enemy_names = { false, Color3.new()},
    enemy_weapon = { false, Color3.new()},
    enemy_distance = false,
    enemy_health = false,

    -- priority
    priority_chams = { false, Color3.new(1, 1, 1), Color3.new(1, 1, 1), .25, .75, true },
    priority_boxes = { false, Color3.new(), Color3.new(), 0.95 },
    priority_healthbar = { false, Color3.new(), Color3.new() },
    priority_kevlarbar = { false, Color3.new(), Color3.new() },
    priority_arrow = { false, Color3.new(), 0.5 },
    priority_names = { false, Color3.new()},
    priority_weapon = { false, Color3.new()},
    priority_distance = false,
    priority_health = false,

    font = 'Plex',
    textsize = 13,

    -- tables
    players = {},
    priority_players = {},
    connections = {},
    visiblecheckparams = {}
}

-- index optimisations
local NEWCF     = CFrame.new
local NEWVEC2   = Vector2.new
local NEWCOLOR3 = Color3.new

local MIN       = math.min
local MAX       = math.max
local ATAN2     = math.atan2
local CLAMP     = math.clamp
local FLOOR     = math.floor
local SIN       = math.sin
local COS       = math.cos
local RAD       = math.rad

local LEN       = string.len
local LOWER     = string.lower
local SUB       = string.sub

local TINSERT   = table.insert
local TFIND     = table.find

-- functions
function esp:draw(a, b)
    local instance = Drawing.new(a)
    if type(b) == 'table' then
        for property, value in next, b do
            instance[property] = value
        end
    end
    return instance
end

function esp:create(a, b)
    local instance = Instance.new(a)
    if type(b) == 'table' then
        for property, value in next, b do
            instance[property] = value
        end
    end
    return instance
end

local folder = esp:create('Folder', { Parent = coregui })

function esp:setproperties(a, b)
    for i, v in next, b do
        a[i] = v
    end
    return a
end

function esp:raycast(a, b, c)
    c = type(c) == 'table' and c or {}
    local params = RaycastParams.new()
    params.IgnoreWater = true
    params.FilterType = Enum.RaycastFilterType.Blacklist
    params.FilterDescendantsInstances = c

    local ray = workspace:Raycast(a, b, params)
    if ray ~= nil then
        if ray.Instance.Transparency >= .250 then
            TINSERT(c, ray.Instance)
            local newray = self:raycast(a, b, c)
            if newray ~= nil then
                ray = newray
            end
        end
    end
    return ray
end

function esp.getcharacter(plr)
    return plr.Character
end

function esp.checkalive(plr)
    if not plr then plr = localPlayer end
    local pass = false
    if (plr.Character and plr.Character:FindFirstChild('Humanoid') and plr.Character:FindFirstChild('Head') and plr.Character:FindFirstChild('LeftUpperArm') and plr.Character.Humanoid.Health > 0 and plr.Character.LeftUpperArm.Transparency == 0) then
        pass = true
    end
    return pass
end

function esp.checkteam(plr, bool)
    if not plr then plr = localPlayer end
    return plr ~= localPlayer and bool or plr.Team ~= localPlayer.Team
end

function esp:checkvisible(instance, origin, params)
    if not params then params = {} end
    local hit = self:raycast(camera.CFrame.p, (origin.Position - camera.CFrame.p).unit * 500, { unpack(params), camera, localPlayer.Character })
    return (hit and hit.Instance:IsDescendantOf(instance)) and true or false
end

function esp:check(plr)
    if plr == players.LocalPlayer then return false end
    local pass = true
    local character = self.getcharacter(plr)
    if not self.checkalive(plr) then
        pass = false
    elseif esp.limitdistance and (character.PrimaryPart.CFrame.p - workspace.CurrentCamera.CFrame.p).magnitude > esp.maxdistance then
        pass = false
    elseif esp.teamcheck and not self.checkteam(plr, false) then
        pass = false
    elseif esp.visiblecheck and not self:checkvisible(character, character.Head, esp.visiblecheckparams) then
        pass = false
    end
    return pass
end

function esp:returnoffsets(x, y, minY, z)
    return {
        NEWCF(x, y, z),
        NEWCF(-x, y, z),
        NEWCF(x, y, -z),
        NEWCF(-x, y, -z),
        NEWCF(x, -minY, z),
        NEWCF(-x, -minY, z),
        NEWCF(x, -minY, -z),
        NEWCF(-x, -minY, -z)
    }
end

function esp:returntriangleoffsets(triangle)
    local minX = MIN(triangle.PointA.X, triangle.PointB.X, triangle.PointC.X)
    local minY = MIN(triangle.PointA.Y, triangle.PointB.Y, triangle.PointC.Y)
    local maxX = MAX(triangle.PointA.X, triangle.PointB.X, triangle.PointC.X)
    local maxY = MAX(triangle.PointA.Y, triangle.PointB.Y, triangle.PointC.Y)
    return minX, minY, maxX, maxY
end

function esp:convertnumrange(val, oldmin, oldmax, newmin, newmax)
    return (val - oldmin) * (newmax - newmin) / (oldmax - oldmin) + newmin
end

function esp:fadeviadistance(data)
    return data.limit and 1 - CLAMP(self:convertnumrange(FLOOR(((data.cframe.p - camera.CFrame.p)).magnitude), (data.maxdistance - data.factor), data.maxdistance, 0, 1), 0, 1) or 1
end

function esp:floorvector(vector)
    return NEWVEC2(FLOOR(vector.X), FLOOR(vector.Y))
end

function esp:returnbounding(character)
    local minX, minY, maxX, maxY = esp:returntriangleoffsets(camera:WorldToViewportPoint(character:FindFirstChild('HumanoidRootPart').CFrame * esp:returnoffsets(3, 3, 3, 3)))
    return minX, minY, maxX, maxY
end

-- Ensure the folder is created
if not folder then
    folder = esp:create('Folder', { Parent = coregui })
end

-- Test the drawing function
local circle = esp:draw('Circle', { Position = NEWVEC2(200, 200), Radius = 50, Color = NEWCOLOR3(1, 0, 0), Filled = false, Thickness = 2 })
print("Circle created:", circle)

-- Update ESP every frame
runService.RenderStepped:Connect(function()
    if not esp.enabled then
        return
    end

    for _, plr in pairs(players:GetPlayers()) do
        if plr ~= localPlayer then
            local character = esp.getcharacter(plr)
            if character and esp:check(plr) then
                local minX, minY, maxX, maxY = esp:returnbounding(character)
                print("Player:", plr.Name, "Min:", minX, minY, "Max:", maxX, maxY)
                -- Here you can implement the drawing of ESP boxes, health bars, etc.
            end
        end
    end
end)
